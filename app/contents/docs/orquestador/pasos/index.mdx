---
title: Pasos y flujo de ejecuci√≥n
description: Documentaci√≥n detallada sobre c√≥mo funcionan los pasos dentro del orquestador y qu√© m√©todos puedes usar desde self.
---

## üîÑ ¬øQu√© es un Paso?

En el Orquestador de Lambda, cada unidad de trabajo modular se define como un **paso**. Un paso es una clase que **hereda de `Paso`** (que a su vez extiende de `PasoBase`) y define su l√≥gica dentro del m√©todo `ejecutar()`.

Ejemplo b√°sico:

```python
from orquestador.core.pasos import Paso

class PasoTransformar(Paso):
    def ejecutar(self):
        self.log("Iniciando transformaci√≥n...")
        # tu l√≥gica aqu√≠
```

---

## üß∞ M√©todos disponibles desde `self` (cuando heredas de Paso)

A continuaci√≥n se documentan todos los m√©todos √∫tiles que puedes invocar desde `self` dentro de un paso personalizado:

---

### `self.get_params()`

Devuelve un `dict` con todos los par√°metros disponibles para el paso, fusionando los globales (`config.json -> global`) con los espec√≠ficos del paso.

```python
params = self.get_params()
ruta = params.get("ruta_archivo")
```

---

### `self.obtener_parametro(clave)`

Permite obtener un par√°metro espec√≠fico por clave desde la configuraci√≥n combinada (paso + global).

```python
valor = self.obtener_parametro("archivo_entrada")
```

---

### `self.log(mensaje: str, nivel: str = "INFO")`

Imprime un mensaje en consola con estilo, usando colores seg√∫n el nivel del log. Niveles v√°lidos: `"INFO"`, `"SUCCESS"`, `"WARNING"`, `"ERROR"`.

```python
self.log("Archivo cargado exitosamente", nivel="SUCCESS")
```

---

### `self.set_payload(payload)`

En el Orquestador de Lambda, existe un contexto compartido llamado `payload`. Este contexto act√∫a como un contenedor de datos que se transfiere de un paso a otro durante la ejecuci√≥n.
```python
resultado = {"mensaje": "hola mundo"}
self.set_payload(resultado)
```

---

### `self.get_payload()`

Devuelve el `payload` actual del proceso, que normalmente es el resultado de pasos anteriores. Ideal para cadenas de transformaci√≥n.

```python
data = self.get_payload()
```

---

### `self.validar_parametros_requeridos(claves: list)`

Valida que ciertas claves est√©n presentes en la configuraci√≥n. Lanza un `ValueError` si falta alguna.

```python
self.validar_parametros_requeridos(["archivo_entrada", "formato"])
```

---

### `self.obtener_nombre_paso()`

Devuelve el nombre de la clase actual. √ötil para logs o seguimiento.

```python
nombre = self.obtener_nombre_paso()
```

---

### `self.obtener_carpeta_resultados()`

Devuelve la ruta a la carpeta de resultados. Si se defini√≥ `--ruta_resultados` al ejecutar, se toma esa ruta. Si no, se usa el default `resultados/`.

```python
ruta = self.obtener_carpeta_resultados()
archivo = ruta / "salida.csv"
```

---

### `self.obtener_carpeta_recursos()`

Devuelve la ruta a la carpeta de `recursos/`. Usa la ruta base del proyecto a menos que se sobreescriba con `--ruta_recursos`.

```python
ruta = self.obtener_carpeta_recursos()
```

---

### `self.obtener_carpeta_sql()`

Devuelve la subcarpeta `sql/` dentro de `recursos/`, √∫til si vas a usar consultas o plantillas SQL.

```python
sql_path = self.obtener_carpeta_sql() / "consulta.sql"
```

---

## üß™ Flujo de ejecuci√≥n entre pasos

1. Se define un array de pasos en el `ejecucion.py`
2. El `EjecutorProyecto` recorre cada paso:
   - Llama `set_payload()` con el resultado del paso anterior
   - Llama `ejecutar()`
   - Guarda el resultado usando `get_payload()`
3. Cada paso puede leer configuraci√≥n, escribir resultados, y dejar trazabilidad.

---

## ‚úÖ Recomendaciones para crear pasos

- Hereda de `Paso` y no de `PasoBase`
- Implementa el m√©todo `ejecutar()`
- Usa `self.log()` para trazabilidad clara
- Usa `self.get_params()` en vez de acceder directamente a configuraciones

---

As√≠ se garantiza un flujo modular, claro y reutilizable entre pasos del orquestador.